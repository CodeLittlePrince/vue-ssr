const fs = require('fs')
const resolve = file => path.resolve(__dirname, file)
const favicon = require('koa-favicon')
const Koa = require('koa')
const koaStatic = require('koa-static')
const path = require('path')
const compress = require('koa-compress')
const mount = require('koa-mount')
const portfinder = require('portfinder')
const isProd = process.env.NODE_ENV === 'production'
const chalk = require('chalk')
const serverConfig = require('./config/server.js')
const proxyConfig = require('./config/proxy')
// proxy
const c2k = require('koa2-connect')
const proxy = require('http-proxy-middleware')
// router
const Router = require('koa-router')
const Boom = require('boom')
const bodyParser = require('koa-bodyparser')
const app = new Koa()
const router = new Router()
const serverInfo =
`koa/${require('koa/package.json').version} ` +
`vue-server-renderer/${require('vue-server-renderer/package.json').version}`
const LRU = require('lru-cache')
const { createBundleRenderer } = require('vue-server-renderer')

app.use(
  c2k(
    proxy(proxyConfig.prefix, {
      target: proxyConfig.domain,
      changeOrigin: true, // needed for virtual hosted sites
      pathRewrite: {
        [proxyConfig.prefix] : '', // rewrite path
      }
    }))
)

// https://github.com/alexmingoia/koa-router
app.use(router.routes())
app.use(router.allowedMethods({
  throw: true,
  notImplemented: () => new Boom.notImplemented(),
  methodNotAllowed: () => new Boom.methodNotAllowed()
}))
// 使用bodyparser 解析get,post的参数
app.use(bodyParser())

// 静态文件
const staticServe = (path, cache) => koaStatic(resolve(path), {
  maxage: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0
})
app.use(compress())
app.use(favicon('./favicon.ico'))
app.use(mount('/dist', staticServe('./dist', true)))
// app.use(mount('/manifest.json', staticServe('./manifest.json', true)))

function createRenderer (bundle, options) {
  // https://github.com/vuejs/vue/blob/dev/packages/vue-server-renderer/README.md#why-use-bundlerenderer
  return createBundleRenderer(bundle, Object.assign(options, {
    // for component caching
    cache: new LRU({
      max: 1000,
      maxAge: 1000 * 60 * 15
    }),
    // this is only needed when vue-server-renderer is npm-linked
    basedir: resolve('./dist'),
    // recommended for performance
    runInNewContext: false
  }))
}

// SSR渲染配置
let renderer
let readyPromise
const templatePath = resolve('./src/client/index.html')
if (isProd) {
  // In production: create server renderer using template and built server bundle.
  // The server bundle is generated by vue-ssr-webpack-plugin.
  const template = fs.readFileSync(templatePath, 'utf-8')
  const bundle = require('./dist/vue-ssr-server-bundle.json')
  // The client manifests are optional, but it allows the renderer
  // to automatically infer preload/prefetch links and directly add <script>
  // tags for any async chunks used during render, avoiding waterfall requests.
  const clientManifest = require('./dist/vue-ssr-client-manifest.json')
  renderer = createRenderer(bundle, {
    template,
    clientManifest
  })
} else {
  // In development: setup the dev server with watch and hot-reload,
  // and create a new renderer on bundle / index template update.
  readyPromise = require('./webpack/dev')(
    app,
    templatePath,
    (bundle, options) => {
      renderer = createRenderer(bundle, options)
    }
  )
}

// SSR渲染
function render (ctx) {
  return new Promise((resolve, reject) => {
    const { req } = ctx
    const context = {
      title: 'Vue SSR', // default title
      url: req.url
    }
    renderer.renderToString(context)
      .then(html => {
        ctx.status = 200
        ctx.body = html
        resolve()
      }).catch(err => {
        handleError(err, ctx)
        reject()
      })
  })
}

// 错误处理
const handleError = (err, ctx) => {
  ctx.set('Content-Type', 'text/html')
  ctx.set('Server', serverInfo)
  if (err.url) {
    ctx.redirect(err.url)
  } else if(err.code === 404) {
    ctx.status = 404
    ctx.body = 'Page Not Found'
  } else {
    // Render Error Page or Redirect
    ctx.status = 500
    ctx.body = 'Internal Server Error'
    console.error(`error during render : ${ctx.req.url}`)
    console.error(err.stack)
  }
}

// 处理所有的请求
app.use(async (ctx, next) => {
  if (!isProd) {
    await readyPromise
  }
  try {
    await render(ctx)
    await next()
  } catch {
    await next()
  }
})

// 启动服务
async function serve() {
  let port = serverConfig.port
  // 开发环境，端口如果被占用，自动换个可用接口
  if (!isProd) {
    portfinder.basePort = serverConfig.port
    port = await portfinder.getPortPromise()
    await readyPromise
    console.log()
    console.log('  App running at:')
    console.log(`  - Local:   ${chalk.cyan('http://localhost' + ':' + port)}`)
    console.log(`  - Network: ${chalk.cyan('http://' + serverConfig.ip + ':' + port)}`)
    console.log(`  - Mock:    ${chalk.cyan(proxyConfig.domain)}`)
    console.log()
    console.log('  Note that the development build is not optimized.')
    console.log(`  To create a production build, and take a view of files' size, run ${chalk.cyan('npm run analyze')}.`)
    console.log()
  } else {
    console.log()
    console.log('  The port of the App running at: ' + chalk.cyan(port))
    console.log()
  }
  // log error
  app.on('error', (err, ctx) => {
    console.error('server error', err, ctx)
  })
  app.listen(port)
}

serve()